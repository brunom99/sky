package gps

import (
	"math"
)

/*

	/!\ Warning, this code has been automatically generated by ChatGPT /!\

*/

const EarthRadius = 6371000 // Radius of the Earth in meters

func MoveTowards(lat1, lon1, bearing, distance float64) (float64, float64) {
	// Limit the distance to avoid mathematical errors
	maxTravel := EarthRadius * 0.5 // Half of the Earth's radius (~3,185 km max)
	if distance > maxTravel {
		distance = maxTravel
	}

	// Convert degrees to radians
	lat1Rad := degToRad(lat1)
	lon1Rad := degToRad(lon1)
	bearingRad := degToRad(bearing)

	// Calculate the new latitude
	lat2Rad := math.Asin(math.Sin(lat1Rad)*math.Cos(distance/EarthRadius) +
		math.Cos(lat1Rad)*math.Sin(distance/EarthRadius)*math.Cos(bearingRad))

	// Calculate the new longitude
	lon2Rad := lon1Rad + math.Atan2(
		math.Sin(bearingRad)*math.Sin(distance/EarthRadius)*math.Cos(lat1Rad),
		math.Cos(distance/EarthRadius)-math.Sin(lat1Rad)*math.Sin(lat2Rad),
	)

	// Convert radians to degrees
	lat2 := radToDeg(lat2Rad)
	lon2 := radToDeg(lon2Rad)

	// Correct for pole overflow
	if lat2 > 90 {
		lat2 = 180 - lat2
		lon2 += 180
	} else if lat2 < -90 {
		lat2 = -180 - lat2
		lon2 += 180
	}

	// Normalize longitude to be within [-180, 180]
	// Check if longitude is out of the [-180, 180] range
	if lon2 > 180 {
		lon2 -= 360
	} else if lon2 < -180 {
		lon2 += 360
	}

	// Check for longitude jumps and adjust if necessary
	if math.Abs(lon2-lon1) > 180 {
		// If a jump is detected (i.e., the difference between lon2 and lon1 is greater than 180Â°),
		// adjust the longitude to avoid incorrect overflow
		if lon2 > lon1 {
			lon2 -= 360 // Adjust to avoid overflow to the east
		} else {
			lon2 += 360 // Adjust to avoid overflow to the west
		}
	}

	return lat2, lon2
}

// Calculate the azimuth (bearing) between two points (in degrees)
func CalculateAzimuth(lat1, lon1, lat2, lon2 float64) float64 {
	lat1Rad := degToRad(lat1)
	lon1Rad := degToRad(lon1)
	lat2Rad := degToRad(lat2)
	lon2Rad := degToRad(lon2)

	// Calculate the difference in longitude
	deltaLon := lon2Rad - lon1Rad

	// Calculate the azimuth
	X := math.Cos(lat2Rad) * math.Sin(deltaLon)
	Y := math.Cos(lat1Rad)*math.Sin(lat2Rad) - math.Sin(lat1Rad)*math.Cos(lat2Rad)*math.Cos(deltaLon)
	azimuth := math.Atan2(X, Y)

	return radToDeg(azimuth)
}

// Calculate the distance between two points using the Haversine formula
func CalculateDistance(lat1, lon1, lat2, lon2 float64) float64 {
	lat1Rad := degToRad(lat1)
	lon1Rad := degToRad(lon1)
	lat2Rad := degToRad(lat2)
	lon2Rad := degToRad(lon2)

	// Haversine formula
	deltaLat := lat2Rad - lat1Rad
	deltaLon := lon2Rad - lon1Rad
	a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) + math.Cos(lat1Rad)*math.Cos(lat2Rad)*math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	distance := EarthRadius * c // Returns the distance in meters

	return distance
}

// Convert degrees to radians
func degToRad(deg float64) float64 {
	return deg * math.Pi / 180.0
}

// Convert radians to degrees
func radToDeg(rad float64) float64 {
	return rad * 180.0 / math.Pi
}
